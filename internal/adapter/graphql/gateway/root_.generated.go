// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package gateway

import (
	"bytes"
	"context"
	"errors"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
	RequirePermission func(ctx context.Context, obj any, next graphql.Resolver, permission string) (res any, err error)
}

type ComplexityRoot struct {
	GetSecurityImagePayload struct {
		Email          func(childComplexity int) int
		SecurityImage  func(childComplexity int) int
		SecurityPhrase func(childComplexity int) int
	}

	Mutation struct {
		GetSecurityImage       func(childComplexity int, input GetSecurityImageInput) int
		ProcessAuthToken       func(childComplexity int, input ProcessAuthTokenInput) int
		SaveSecurityImage      func(childComplexity int, input SaveSecurityImageInput) int
		SendConfirmationCode   func(childComplexity int, input SendConfirmationCodeInput) int
		VerifyConfirmationCode func(childComplexity int, input VerifyConfirmationCodeInput) int
	}

	ProcessAuthTokenPayload struct {
		UserID func(childComplexity int) int
	}

	Query struct {
		Dummy func(childComplexity int) int
	}

	SaveSecurityImagePayload struct {
		Email func(childComplexity int) int
	}

	SendConfirmationCodePayload struct {
		Recipient func(childComplexity int) int
	}

	VerifyConfirmationCodePayload struct {
		Recipient func(childComplexity int) int
	}

	VoidPayload struct {
		Ok func(childComplexity int) int
	}
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(ctx context.Context, typeName, field string, childComplexity int, rawArgs map[string]any) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "GetSecurityImagePayload.email":
		if e.complexity.GetSecurityImagePayload.Email == nil {
			break
		}

		return e.complexity.GetSecurityImagePayload.Email(childComplexity), true

	case "GetSecurityImagePayload.security_image":
		if e.complexity.GetSecurityImagePayload.SecurityImage == nil {
			break
		}

		return e.complexity.GetSecurityImagePayload.SecurityImage(childComplexity), true

	case "GetSecurityImagePayload.security_phrase":
		if e.complexity.GetSecurityImagePayload.SecurityPhrase == nil {
			break
		}

		return e.complexity.GetSecurityImagePayload.SecurityPhrase(childComplexity), true

	case "Mutation.getSecurityImage":
		if e.complexity.Mutation.GetSecurityImage == nil {
			break
		}

		args, err := ec.field_Mutation_getSecurityImage_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.GetSecurityImage(childComplexity, args["input"].(GetSecurityImageInput)), true

	case "Mutation.processAuthToken":
		if e.complexity.Mutation.ProcessAuthToken == nil {
			break
		}

		args, err := ec.field_Mutation_processAuthToken_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ProcessAuthToken(childComplexity, args["input"].(ProcessAuthTokenInput)), true

	case "Mutation.saveSecurityImage":
		if e.complexity.Mutation.SaveSecurityImage == nil {
			break
		}

		args, err := ec.field_Mutation_saveSecurityImage_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SaveSecurityImage(childComplexity, args["input"].(SaveSecurityImageInput)), true

	case "Mutation.sendConfirmationCode":
		if e.complexity.Mutation.SendConfirmationCode == nil {
			break
		}

		args, err := ec.field_Mutation_sendConfirmationCode_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SendConfirmationCode(childComplexity, args["input"].(SendConfirmationCodeInput)), true

	case "Mutation.verifyConfirmationCode":
		if e.complexity.Mutation.VerifyConfirmationCode == nil {
			break
		}

		args, err := ec.field_Mutation_verifyConfirmationCode_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.VerifyConfirmationCode(childComplexity, args["input"].(VerifyConfirmationCodeInput)), true

	case "ProcessAuthTokenPayload.user_id":
		if e.complexity.ProcessAuthTokenPayload.UserID == nil {
			break
		}

		return e.complexity.ProcessAuthTokenPayload.UserID(childComplexity), true

	case "Query._dummy":
		if e.complexity.Query.Dummy == nil {
			break
		}

		return e.complexity.Query.Dummy(childComplexity), true

	case "SaveSecurityImagePayload.email":
		if e.complexity.SaveSecurityImagePayload.Email == nil {
			break
		}

		return e.complexity.SaveSecurityImagePayload.Email(childComplexity), true

	case "SendConfirmationCodePayload.recipient":
		if e.complexity.SendConfirmationCodePayload.Recipient == nil {
			break
		}

		return e.complexity.SendConfirmationCodePayload.Recipient(childComplexity), true

	case "VerifyConfirmationCodePayload.recipient":
		if e.complexity.VerifyConfirmationCodePayload.Recipient == nil {
			break
		}

		return e.complexity.VerifyConfirmationCodePayload.Recipient(childComplexity), true

	case "VoidPayload.ok":
		if e.complexity.VoidPayload.Ok == nil {
			break
		}

		return e.complexity.VoidPayload.Ok(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputGetSecurityImageInput,
		ec.unmarshalInputProcessAuthTokenInput,
		ec.unmarshalInputSaveSecurityImageInput,
		ec.unmarshalInputSendConfirmationCodeInput,
		ec.unmarshalInputVerifyConfirmationCodeInput,
	)
	first := true

	switch opCtx.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, opCtx.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, opCtx.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../../../../graphql/auth.graphql", Input: `# ─────────────────────────────
# Enum
# ─────────────────────────────

enum DeliveryMethod {
  EMAIL
}

# ─────────────────────────────
# Input types
# ─────────────────────────────

input SendConfirmationCodeInput {
  method: DeliveryMethod!
  recipient: String!
}

type SendConfirmationCodePayload {
  recipient: String!
}

input VerifyConfirmationCodeInput {
  recipient: String!
  code: String!
}

type VerifyConfirmationCodePayload {
  recipient: String!
}

input SaveSecurityImageInput {
  email: String!
  security_image: String!
  security_phrase: String!
}

type SaveSecurityImagePayload {
  email: String!
}

input GetSecurityImageInput {
  email: String!
}

type GetSecurityImagePayload {
  email: String!
  security_image: String!
  security_phrase: String!
}

input ProcessAuthTokenInput {
  id_token: String!
}

type ProcessAuthTokenPayload {
  user_id: String!
}

# ─────────────────────────────
# Query
# ─────────────────────────────

type Query {
  _dummy: String
}

# ─────────────────────────────
# Mutation fields
# ─────────────────────────────

extend type Mutation {
  sendConfirmationCode(input: SendConfirmationCodeInput!): SendConfirmationCodePayload!
  verifyConfirmationCode(input: VerifyConfirmationCodeInput!): VerifyConfirmationCodePayload!
  saveSecurityImage(input: SaveSecurityImageInput!):SaveSecurityImagePayload!
  getSecurityImage(input: GetSecurityImageInput!):GetSecurityImagePayload!
  processAuthToken(input: ProcessAuthTokenInput!): ProcessAuthTokenPayload!
}
`, BuiltIn: false},
	{Name: "../../../../graphql/common.graphql", Input: `# ─────────────────────────────
# Directive mutation and query options
# ─────────────────────────────

directive @requirePermission(permission: String!) on FIELD_DEFINITION

# ─────────────────────────────
# Common types
# ─────────────────────────────

type VoidPayload {
  ok: Boolean
}`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
